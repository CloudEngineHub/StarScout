---
title: "fake_stars_modeling"
output: pdf_document
---

```{r}
library(dplyr)
library(tidyr)
library(nlme)
library(tseries)
library(MuMIn)
```

```{r}
repos = read.csv("data/model_stars.csv")
colnames(repos) <- c("repo", "month", "n_stars_all", "n_stars_fake", "n_stars_real")
```

```{r}
repos <- repos %>%
  arrange(repo, month)

repos <- repos %>%
  group_by(repo) %>%       # Group by repo_name
  mutate(
    # number of reals stars x months ago
    real1 = lag(n_stars_real, 1),
    real2 = lag(n_stars_real, 2),
    real3 = lag(n_stars_real, 3),
    # number of fake stars x months ago
    fake0 = n_stars_fake,
    fake1 = lag(n_stars_fake, 1),
    fake2 = lag(n_stars_fake, 2),
    fake3 = lag(n_stars_fake, 3),
    # sum of reals stars until x months ago
    sumReal = cumsum(n_stars_real),
    sumReal1 = lag(sumReal, 1),
    sumReal2 = lag(sumReal, 2),
    sumReal3 = lag(sumReal, 3),
    sumReal4 = lag(sumReal, 4),
    # sum of fake stars until x months ago
    sumFake = cumsum(n_stars_fake),
    sumFake1 = lag(sumFake, 1),
    sumFake2 = lag(sumFake, 2),
    sumFake3 = lag(sumFake, 3),
    sumFake4 = lag(sumFake, 4),
    fake_percentage = n_stars_fake/(n_stars_real+n_stars_fake)
  ) %>%
  ungroup() %>% # Remove grouping
  drop_na()

repos <- repos %>%
  group_by(repo) %>%
  mutate(time_label = row_number()) %>% #relabel the time using integers starting from 1
  ungroup()
```

```{r}
# first order autoregressive model
ar1_star = lme(log(n_stars_real + 1) ~ log(real1 + 1) + log(fake0 + 1) + log(fake1 + 1) + log(sumReal2 + 1) + log(sumFake2 + 1),
          random = ~ 1 | repo,
          correlation = corAR1(form = ~ time_label | repo),
          data = repos)
summary(ar1_star)
```

```{r}
print(r.squaredGLMM(ar1_star))
```

```{r}
residuals_ar1_star <- resid(ar1_star)
adf_test_result <- adf.test(residuals_ar1_star)

# Display the test results
print(adf_test_result)
# Plotting residuals to check assumptions
plot(ar1_star, which = 1)  # Residuals vs Fitted values
qqnorm(residuals_ar1_star)    # Q-Q plot for normality of residuals
qqline(residuals_ar1_star)
```

```{r}
# second order autoregressive model
ar2_star = lme(
          log(n_stars_real + 1) 
            ~ log(real1 + 1) + 
              log(real2 + 1) + 
              log(fake0 + 1) +
              log(fake1 + 1) + 
              log(fake2 + 1) + 
              log(sumReal3 + 1) + 
              log(sumFake3 + 1),
          random = ~ 1 | repo,
          correlation = corARMA(form = ~ time_label | repo, p = 2),
          data = repos)
summary(ar2_star)
```
```{r}
print(r.squaredGLMM(ar2_star))
```

```{r}
# third-order
ar3_star = lme(
          log2(n_stars_real + 1) 
            ~ log2(real1 + 1) + 
              log2(real2 + 1) + 
              log2(real3 + 1) +
              log2(fake0 + 1) + 
              log2(fake1 + 1) + 
              log2(fake2 + 1) + 
              log2(fake3 + 1) +
              log2(sumReal4 + 1) + 
              log2(sumFake4 + 1),
          random = ~ 1 | repo,
          correlation = corARMA(form = ~ time_label | repo, p = 2),
          data = repos)
summary(ar3_star)
```
```{r}
print(r.squaredGLMM(ar3_star))
```
```{r}
library(plm)
library(lmtest)
# fixed effects model 
panel_star <- plm(real ~ real1 + fake1, 
                    data = repos,
                    index = c("repo_name", "time_label"), 
                    model = "within")
coeftest(panel_star, vcov. = vcovHC, type = "HC1")
```

```{r}
library(tseries)
residuals_ar1_star <- resid(ar1_star)
# Apply the ADF test on the residuals
adf_test_result <- adf.test(residuals_ar1_star)

# Display the test results
print(adf_test_result)
# Plotting residuals to check assumptions
plot(ar1_star, which = 1)  # Residuals vs Fitted values
qqnorm(residuals_ar1_star)    # Q-Q plot for normality of residuals
qqline(residuals_ar1_star)
```

```{r}
ks.test(residuals_ar1_star, "pnorm", 0, 1)
```

```{r}
library(nlme)
ar2_star = lme(real ~ real1 + real2 + fake1 + fake2 + sumReal3 + sumFake3,
          random = ~ 1 | repo_name,
          correlation = corARMA(form = ~ time_label | repo_name, p = 2),
          data = repos)
summary(ar2_star)
```

```{r}
library(MuMIn)
r_squared_values <- r.squaredGLMM(ar2_star)

# Print the R-squared values
print(r_squared_values)
```
```{r}
library(tseries)
residuals_ar2_star <- resid(ar2_star)
# Apply the ADF test on the residuals
adf_test_result <- adf.test(residuals_ar2_star)

# Display the test results
print(adf_test_result)
# Plotting residuals to check assumptions
plot(ar1_star, which = 1)  # Residuals vs Fitted values
qqnorm(residuals_ar2_star)    # Q-Q plot for normality of residuals
qqline(residuals_ar2_star)
```
